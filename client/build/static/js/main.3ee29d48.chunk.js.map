{"version":3,"sources":["utils/API.js","Home.tsx","App.js","serviceWorker.js","index.js"],"names":["axios","get","textData","post","id","Home","props","componentDidMount","GetTexts","sSender","window","prompt","trim","setState","sender","API","then","response","imageList","data","texts","catch","err","alert","SendText","FormData","append","state","description","deleteFile","success","filter","el","_id","objDiv","document","getElementById","scrollTop","scrollHeight","className","this","map","text","createdAt","slice","onClick","type","onChange","event","target","value","PureComponent","App","exact","path","component","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"iOAEe,EAEJ,WACT,OAAOA,IAAMC,IAAI,eAHJ,EAMD,SAASC,GACrB,OAAOF,IAAMG,KAAK,aAAcD,IAPnB,EAUF,SAASE,GACpB,OAAOJ,IAAMC,IAAI,cAAgBG,I,OC2FpBC,E,kDA5FX,WAAYC,GAAY,IAAD,8BACnB,cAAMA,IASVC,kBAAoB,WAChB,EAAKC,WACL,IAAIC,EAAUC,OAAOC,OAAO,iBACd,MAAXF,IACKA,EAAQG,OAIR,EAAKC,SAAS,CAACC,OAAQL,IAHvB,EAAKI,SAAS,CAACC,OAAQ,gBAfZ,EA8BvBN,SAAW,WACPO,IACKC,MAAK,SAAAC,GACF,EAAKJ,SAAS,CAAEK,UAAWD,EAASE,KAAKC,WAE5CC,OAAM,SAAAC,GAAG,OAAIC,MAAMD,OAnCL,EAsCvBE,SAAW,WACP,IAAItB,EAAW,IAAIuB,SACnBvB,EAASwB,OAAO,SAAU,EAAKC,MAAMb,QACrCZ,EAASwB,OAAO,cAAe,EAAKC,MAAMC,aAE1Cb,EAAa,CAACD,OAAQ,EAAKa,MAAMb,OAAQc,YAAa,EAAKD,MAAMC,cAC5DZ,MAAK,SAACC,GACH,EAAKT,cAERa,OAAM,SAAAC,GAAG,OAAIC,MAAM,UAAYD,MAChC,EAAKd,YAhDU,EAmDvBqB,WAAa,SAACzB,GACVW,EAAeX,GACVY,MAAK,SAACC,GACCA,EAASE,KAAKW,SACd,EAAKjB,SAAS,CAAEK,UAAW,EAAKS,MAAMT,UAAUa,QAAO,SAAAC,GAAE,OAAIA,EAAGC,MAAQ7B,UAG/EiB,OAAM,SAAAC,GAAG,OAAIC,MAAMD,OAvDxB,EAAKK,MAAQ,CACTb,OAAQ,GACRc,YAAa,GACbV,UAAW,IANI,E,sDAsBvB,WAEI,IAAMgB,EAASC,SAASC,eAAe,UAC3B,MAARF,IACAA,EAAOG,UAAYH,EAAOI,gB,oBAmClC,WAAS,IAAD,OACJ,OACI,qBAAKC,UAAY,aAAjB,SACI,sBAAKA,UAAY,aAAjB,UACC,qBAAKA,UAAY,SAASnC,GAAK,SAA/B,SACIoC,KAAKb,MAAMT,UAAUuB,KAAI,SAACC,GAAD,OACtB,gCACI,mBAAGH,UAAU,SAAb,SAAuBG,EAAK5B,SAC5B,wBAAOyB,UAAY,OAAnB,UAA2BG,EAAKC,UAAUC,MAAM,GAAI,IAApD,IAA0DF,EAAKC,UAAUC,MAAM,IAAK,MACpF,wBAAQL,UAAY,eAAeM,QAAS,kBAAM,EAAKhB,WAAWa,EAAKT,MAAvE,oBACA,mBAAGM,UAAW,QAAd,SAAuBG,EAAKd,sBAKxC,sBAAKW,UAAU,QAAf,UACI,uBACInC,GAAK,UACLmC,UAAY,WACZO,KAAK,OACLC,SAAU,SAAAC,GAAK,OAAI,EAAKnC,SAAS,CAAEe,YAAaoB,EAAMC,OAAOC,SAC7DA,MAAOV,KAAKb,MAAMC,cAEtB,wBAAQW,UAAU,SAASnC,GAAK,aAAYyC,QAASL,KAAKhB,SAA1D,8B,GArFD2B,iBCGJC,EAVH,kBACX,cAAC,IAAD,UACC,8BACC,cAAC,IAAD,UACC,cAAC,IAAD,CAAOC,OAAK,EAACC,KAAK,IAAIC,UAAWlD,WCEjBmD,QACa,cAA7B9C,OAAO+C,SAASC,UAEe,UAA7BhD,OAAO+C,SAASC,UAEhBhD,OAAO+C,SAASC,SAASC,MACvB,2DCVRC,IAASC,OAAO,cAAC,EAAD,IAAS1B,SAASC,eAAe,SDmHzC,kBAAmB0B,WACrBA,UAAUC,cAAcC,MAAMhD,MAAK,SAAAiD,GACjCA,EAAaC,kB","file":"static/js/main.3ee29d48.chunk.js","sourcesContent":["import axios from 'axios';\n\nexport default {\n\t// Gets all books\n\tgetTexts: function() {\n\t\treturn axios.get('/api/texts');\n    },\n    \n    sendText: function(textData) {\n\t\treturn axios.post('/api/texts', textData);\n\t},\n\t// Gets the book with the given id\n\tdeleteText: function(id) {\n\t\treturn axios.get('/api/texts/' + id);\n\t}\n\t// Saves a book to the database\n\t\n};","import React, { PureComponent } from 'react';\nimport './App.css';\nimport API from './utils/API';\n\n\ninterface texts {\n    imageList: any[];\n    description:string;\n    sender: string;\n};\n\nclass Home extends PureComponent<{}, texts> {\n    constructor(props: {}) {\n        super(props);\n\n        this.state = {\n            sender: '',\n            description: '',\n            imageList: [],\n        };\n    }\n\n    componentDidMount = () => {\n        this.GetTexts();\n        var sSender = window.prompt('Your name is:'); \n        if(sSender != null){\n            if(!sSender.trim()){\n                this.setState({sender: 'Anonymous'});\n            }\n            else {\n                this.setState({sender: sSender});\n            }\n        }\n    }\n    componentDidUpdate() {\n        // I was not using an li but may work to keep your div scrolled to the bottom as li's are getting pushed to the div\n        const objDiv = document.getElementById('scroll');\n        if (objDiv!=null){\n            objDiv.scrollTop = objDiv.scrollHeight;\n        }\n    }\n\n    GetTexts = () => {\n        API.getTexts()\n            .then(response => {\n                this.setState({ imageList: response.data.texts });\n            })\n            .catch(err => alert(err));\n    }\n\n    SendText = () => {\n        let textData = new FormData();\n        textData.append('sender', this.state.sender);\n        textData.append('description', this.state.description);\n\n        API.sendText({sender: this.state.sender, description: this.state.description})\n            .then((response) => {\n                this.GetTexts();\n            })\n            .catch(err => alert('Error: ' + err));\n            this.GetTexts();\n    }\n\n    deleteFile = (id: any) => {\n        API.deleteText(id)\n            .then((response) => {\n                if (response.data.success) {\n                    this.setState({ imageList: this.state.imageList.filter(el => el._id !== id)});\n                }\n            })\n            .catch(err => alert(err));\n    }\n\n    render(){\n        return (\n            <div className = \"everything\">\n                <div className = \"chatandbox\">\n                 <div className = \"scroll\" id = \"scroll\">\n                    {this.state.imageList.map((text) => (\n                        <div >\n                            <b className=\"Sender\">{text.sender}</b>\n                            <small className = \"Date\">{text.createdAt.slice(0, -14)} {text.createdAt.slice(11, -5)}</small>\n                            <button className = \"deletebutton\" onClick={() => this.deleteFile(text._id)}>Delete</button>\n                            <p className= \"Textt\">{text.description}</p>\n                            \n                        </div>\n                    ))}\n                </div>\n                <div className=\"input\">\n                    <input\n                        id = \"textbox\"\n                        className = \"inputBox\"\n                        type=\"text\"\n                        onChange={event => this.setState({ description: event.target.value })}\n                        value={this.state.description}\n                    />\n                    <button className=\"button\" id = \"sendButton\"onClick={this.SendText}>Send</button>\n                </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Home;","import React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport Home from './Home';\n\nconst App = () => (\n\t<Router>\n\t\t<div>\n\t\t\t<Switch>\n\t\t\t\t<Route exact path=\"/\" component={Home} />\n\t\t\t</Switch>\n\t\t</div>\n\t</Router>\n);\n\nexport default App;","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n      // [::1] is the IPv6 localhost address.\n      window.location.hostname === '[::1]' ||\n      // 127.0.0.1/8 is considered localhost for IPv4.\n      window.location.hostname.match(\n        /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n      )\n  );\n  \n  export function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n      // The URL constructor is available in all browsers that support SW.\n      const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n      if (publicUrl.origin !== window.location.origin) {\n        // Our service worker won't work if PUBLIC_URL is on a different origin\n        // from what our page is served on. This might happen if a CDN is used to\n        // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n        return;\n      }\n  \n      window.addEventListener('load', () => {\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n  \n        if (isLocalhost) {\n          // This is running on localhost. Let's check if a service worker still exists or not.\n          checkValidServiceWorker(swUrl, config);\n  \n          // Add some additional logging to localhost, pointing developers to the\n          // service worker/PWA documentation.\n          navigator.serviceWorker.ready.then(() => {\n            console.log(\n              'This web app is being served cache-first by a service ' +\n                'worker. To learn more, visit https://goo.gl/SC7cgQ'\n            );\n          });\n        } else {\n          // Is not local host. Just register service worker\n          registerValidSW(swUrl, config);\n        }\n      });\n    }\n  }\n  \n  function registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n      .register(swUrl)\n      .then(registration => {\n        registration.onupdatefound = () => {\n          const installingWorker = registration.installing;\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and\n                // the fresh content will have been added to the cache.\n                // It's the perfect time to display a \"New content is\n                // available; please refresh.\" message in your web app.\n                console.log('New content is available; please refresh.');\n  \n                // Execute callback\n                if (config.onUpdate) {\n                  config.onUpdate(registration);\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // \"Content is cached for offline use.\" message.\n                console.log('Content is cached for offline use.');\n  \n                // Execute callback\n                if (config.onSuccess) {\n                  config.onSuccess(registration);\n                }\n              }\n            }\n          };\n        };\n      })\n      .catch(error => {\n        console.error('Error during service worker registration:', error);\n      });\n  }\n  \n  function checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n      .then(response => {\n        // Ensure service worker exists, and that we really are getting a JS file.\n        if (\n          response.status === 404 ||\n          response.headers.get('content-type').indexOf('javascript') === -1\n        ) {\n          // No service worker found. Probably a different app. Reload the page.\n          navigator.serviceWorker.ready.then(registration => {\n            registration.unregister().then(() => {\n              window.location.reload();\n            });\n          });\n        } else {\n          // Service worker found. Proceed as normal.\n          registerValidSW(swUrl, config);\n        }\n      })\n      .catch(() => {\n        console.log(\n          'No internet connection found. App is running in offline mode.'\n        );\n      });\n  }\n  \n  export function unregister() {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.ready.then(registration => {\n        registration.unregister();\n      });\n    }\n  }","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nserviceWorker.unregister();"],"sourceRoot":""}